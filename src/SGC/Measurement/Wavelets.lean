/-
Copyright (c) 2025 SGC Project. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: SGC Formalization Team
-/
import SGC.Measurement.Interfaces
import SGC.Spectral.Core.Assumptions

/-!
# Stage 1: Non-Normal-Safe Multiscale Analysis

This module implements the wavelet engine that works for irreversible/non-normal systems
and produces auditable quantities.

## Core Insight

Standard spectral methods (eigendecomposition) fail for non-normal operators because:
1. Eigenvalues can be highly sensitive to perturbations (pseudospectral instability)
2. Eigenvectors may be nearly parallel (ill-conditioned basis)
3. Transient growth can occur even when all eigenvalues have negative real parts

The solution: use **functional calculus** based on resolvents/contours, not eigenvalues.

## Diffusion-Telescoping Wavelets

For a generator L, define wavelets via heat kernel differences:

    Ψ_j(L) = exp(t_j L) - exp(t_{j-1} L)

on a dyadic schedule t_j = 2^j t_0. This:
- Avoids diagonalization entirely
- Produces a near-tight frame when L is sectorial
- Works for non-reversible (non-normal) generators

## The Sectorial Condition

An operator L is **sectorial** if its numerical range lies in a sector:

    W(L) ⊆ { z : |arg(z - ω)| ≤ θ } for some ω ∈ ℝ, θ < π/2

For Markov generators: the symmetric part H = (L + L*)/2 controls the sector,
and the spectral gap of H bounds transient growth.

## References

- [Davies] "One-Parameter Semigroups" (sectorial operators)
- [Hammond et al.] "Wavelets on Graphs via Spectral Graph Theory"
- [Trefethen & Embree] "Spectra and Pseudospectra"
-/

noncomputable section

namespace SGC.Measurement

open Finset BigOperators Matrix SGC

variable {V : Type*} [Fintype V] [DecidableEq V] [Nonempty V]

/-! ### 1. Heat Kernel (Exponential of Generator) -/

/-- **Heat Kernel**: The matrix exponential exp(tL).

    This is the fundamental propagator for the dynamics generated by L.
    For t ≥ 0, exp(tL) maps initial distributions to time-t distributions.

    **Implementation Note**: We axiomatize the matrix exponential here.
    A full implementation would use power series or Padé approximants. -/
axiom HeatKernel (L : Matrix V V ℝ) (t : ℝ) : Matrix V V ℝ

/-- Heat kernel at t=0 is the identity. -/
axiom HeatKernel_zero (L : Matrix V V ℝ) : HeatKernel L 0 = 1

/-- Heat kernel semigroup property: exp((s+t)L) = exp(sL) * exp(tL). -/
axiom HeatKernel_add (L : Matrix V V ℝ) (s t : ℝ) :
  HeatKernel L (s + t) = HeatKernel L s * HeatKernel L t

/-- Heat kernel preserves stationarity: exp(tL) *ᵥ 1 = 1 when L kills 1. -/
axiom HeatKernel_stationary (L : Matrix V V ℝ) (hL : L *ᵥ constant_vec_one = 0) (t : ℝ) :
  HeatKernel L t *ᵥ constant_vec_one = constant_vec_one

/-! ### 2. Diffusion Wavelets -/

/-- **Dyadic Time Schedule**: t_j = t_0 * 2^j for scale index j.

    This is the standard multiscale schedule for wavelet analysis. -/
def dyadicTime (t₀ : ℝ) (j : ℕ) : ℝ := t₀ * (2 : ℝ)^j

/-- **Diffusion Wavelet**: Ψ_j(L) = exp(t_j L) - exp(t_{j-1} L).

    Captures dynamics at scale j by taking the difference of heat kernels.
    This is a band-pass filter in the spectral domain.

    For j = 0, we use exp(t_0 L) - I as the finest scale wavelet. -/
def DiffusionWavelet (L : Matrix V V ℝ) (t₀ : ℝ) (j : ℕ) : Matrix V V ℝ :=
  if j = 0 then
    HeatKernel L t₀ - 1
  else
    HeatKernel L (dyadicTime t₀ j) - HeatKernel L (dyadicTime t₀ (j - 1))

/-- **Wavelet Coefficient**: The projection of f onto wavelet Ψ_j.

    W_j f = Ψ_j(L) *ᵥ f

    Measures the "activity" of f at scale j. -/
def WaveletCoeff (L : Matrix V V ℝ) (t₀ : ℝ) (j : ℕ) (f : V → ℝ) : V → ℝ :=
  DiffusionWavelet L t₀ j *ᵥ f

/-- **Multiscale Representation**: Stack of wavelet coefficients at all scales.

    W f = (W_0 f, W_1 f, ..., W_{J-1} f)

    This is the complete multiscale decomposition of f. -/
def MultiscaleCoeffs (L : Matrix V V ℝ) (t₀ : ℝ) (J : ℕ) (f : V → ℝ) : Fin J → (V → ℝ) :=
  fun j => WaveletCoeff L t₀ j.val f

/-! ### 3. Telescoping Property -/

/-- **Telescoping Sum**: Wavelets sum to coarse-to-fine difference.

    Σ_{j=0}^{J-1} Ψ_j = exp(t_J L) - I

    This is the key identity: the wavelets form a partition of unity
    (up to the residual at the coarsest scale). -/
theorem wavelet_telescoping (L : Matrix V V ℝ) (t₀ : ℝ) (ht₀ : 0 < t₀) (J : ℕ) (hJ : 0 < J) :
    ∑ j : Fin J, DiffusionWavelet L t₀ j.val = HeatKernel L (dyadicTime t₀ (J - 1)) - 1 := by
  sorry  -- Telescoping sum; requires careful bookkeeping of indices

/-- **Residual at Coarse Scale**: exp(t_J L) captures the "slow" component.

    For large J, this approaches the projection onto the stationary distribution
    (if L has a spectral gap). -/
def CoarseResidual (L : Matrix V V ℝ) (t₀ : ℝ) (J : ℕ) : Matrix V V ℝ :=
  HeatKernel L (dyadicTime t₀ J)

/-! ### 4. Frame Bounds for Diffusion Wavelets -/

/-- **Diffusion Frame**: The collection of diffusion wavelets forms an analysis frame.

    The frame bounds A, B satisfy:
    A ‖f‖² ≤ Σ_j ‖Ψ_j f‖² ≤ B ‖f‖²

    **Key insight**: For sectorial generators, this frame is near-tight
    (B/A ≈ 1), providing auditable multiscale analysis. -/
structure DiffusionFrame (V : Type*) [Fintype V] where
  /-- The generator -/
  L : Matrix V V ℝ
  /-- Base timescale -/
  t₀ : ℝ
  /-- Number of scales -/
  J : ℕ
  /-- Lower frame bound -/
  A : ℝ
  /-- Upper frame bound -/
  B : ℝ
  /-- Positivity -/
  t₀_pos : 0 < t₀
  J_pos : 0 < J
  A_pos : 0 < A
  B_ge_A : A ≤ B

/-- Convert a DiffusionFrame to an AnalysisFrame. -/
def DiffusionFrame.toAnalysisFrame (df : DiffusionFrame V) : AnalysisFrame V df.J where
  ψ := fun j v => (DiffusionWavelet df.L df.t₀ j.val *ᵥ (fun w => if w = v then 1 else 0)) v
  A := df.A
  B := df.B
  A_pos := df.A_pos
  B_ge_A := df.B_ge_A

/-! ### 5. Sectorial Condition -/

/-- **Sectorial Generator**: L such that L + L* is controlled.

    A generator L is sectorial if the symmetric part H = (L + L*)/2
    is negative semidefinite on the orthogonal complement of constants.

    This is the key hypothesis for non-normal operators:
    it implies that transient growth is bounded by the spectral gap of H. -/
structure SectorialGenerator (V : Type*) [Fintype V] where
  /-- The generator -/
  L : Matrix V V ℝ
  /-- The symmetric part H = (L + L*)/2 -/
  H : Matrix V V ℝ
  /-- Stationary distribution -/
  pi_dist : V → ℝ
  /-- Positivity of π -/
  pi_pos : ∀ v, 0 < pi_dist v
  /-- H is the symmetric part of L in L²(π) -/
  H_is_symmetric_part : ∀ u v,
    inner_pi pi_dist (H *ᵥ u) v =
    (inner_pi pi_dist (L *ᵥ u) v + inner_pi pi_dist u (L *ᵥ v)) / 2
  /-- H is negative semidefinite on 1⊥ -/
  H_neg_semidef : ∀ u, inner_pi pi_dist u constant_vec_one = 0 →
    inner_pi pi_dist (H *ᵥ u) u ≤ 0
  /-- H has spectral gap γ > 0 -/
  gap : ℝ
  gap_pos : 0 < gap
  gap_coercivity : ∀ u, inner_pi pi_dist u constant_vec_one = 0 →
    inner_pi pi_dist (H *ᵥ u) u ≤ -gap * inner_pi pi_dist u u

/-- **Sector Envelope Bound**: For sectorial generators, ‖exp(tL) P‖ ≤ exp(-γt).

    This is the fundamental stability result for non-normal systems:
    the transient growth is controlled by the spectral gap of H, not
    the eigenvalues of L.

    P is the projection onto 1⊥ (mean-zero functions). -/
theorem sectorial_envelope_decay (sg : SectorialGenerator V)
    (f : V → ℝ) (hf : inner_pi sg.pi_dist f constant_vec_one = 0) (t : ℝ) (ht : 0 ≤ t) :
    inner_pi sg.pi_dist (HeatKernel sg.L t *ᵥ f) (HeatKernel sg.L t *ᵥ f) ≤
    Real.exp (-2 * sg.gap * t) * inner_pi sg.pi_dist f f := by
  sorry  -- Uses Gronwall's inequality on E(t) = ‖exp(tL)f‖²

/-! ### 6. Safe Scale Band -/

/-- **Finite-Horizon Detection Time (FHDT)**: Minimum time to detect structure.

    t_min = 1 / ‖L‖_op

    Below this time, the dynamics haven't had time to mix,
    so structure detection is unreliable.

    **Axiomatized**: Requires operator norm computation. -/
axiom FHDT (L : Matrix V V ℝ) (pi_dist : V → ℝ) (hπ : ∀ v, 0 < pi_dist v) : ℝ

/-- **Mixing Time**: Maximum time before full equilibration.

    t_max = C / γ for some constant C

    Beyond this time, everything looks like the stationary distribution,
    so structure detection is meaningless. -/
def MixingTime (gap : ℝ) (C : ℝ) : ℝ := C / gap

/-- **Safe Scale Band**: The range of timescales for valid analysis.

    [t_min, t_max] = [1/‖L‖, C/γ]

    Analysis at scales outside this band either:
    - t < t_min: Sees trivially short dynamics (noise)
    - t > t_max: Sees fully mixed equilibrium (no structure)

    The number of valid scales is approximately log₂(t_max / t_min). -/
structure SafeScaleBand where
  t_min : ℝ
  t_max : ℝ
  t_min_pos : 0 < t_min
  t_max_pos : 0 < t_max
  band_valid : t_min < t_max

/-- Number of dyadic scales in the safe band. -/
def SafeScaleBand.numScales (band : SafeScaleBand) : ℕ :=
  Nat.floor (Real.log (band.t_max / band.t_min) / Real.log 2)

/-! ### 7. Audited Wavelet Analysis -/

/-- **Audited Diffusion Analysis**: Complete multiscale analysis with certificates.

    Bundles:
    - Sectorial generator (ensures envelope decay)
    - Diffusion frame (wavelets with bounds)
    - Safe scale band (ensures meaningful scales)
    - Tightness certificate (ensures representational fidelity)

    This is the primary interface for Stage 1. -/
structure AuditedDiffusionAnalysis (V : Type*) [Fintype V] [DecidableEq V] [Nonempty V] where
  /-- The sectorial generator -/
  gen : SectorialGenerator V
  /-- The diffusion frame -/
  frame : DiffusionFrame V
  /-- Safe scale band -/
  band : SafeScaleBand
  /-- Frame uses generator from gen -/
  frame_uses_gen : frame.L = gen.L
  /-- Base time is in safe band -/
  t₀_in_band : band.t_min ≤ frame.t₀ ∧ frame.t₀ * 2^(frame.J - 1) ≤ band.t_max
  /-- Tightness certificate -/
  tightness : TightnessRatio frame.toAnalysisFrame < 0.1  -- 10% tolerance

end SGC.Measurement
